<!DOCTYPE html>
<html lang="zh-CN">

<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>红色问答调试</title>
   <style>
    html,body{
        width: 100%;
        height: 100%;
        display: flex;
        margin: 0;
        padding: 0;
    }
    button,textarea,body,select,input{
        background-color: #e1ebe7;
        font-family: fusion-pixel-12px-monospaced-zh_hant, serif;
    }
    button:hover {
        background-color: aqua;
        color: red;
        cursor: pointer;
    }
   </style>
   <script src="axios.js"></script>
   <script src="vue.js"></script>
   <script src="vue-quill.js"></script>
   <link rel="stylesheet" href="vue-quill.snow.prod.css">
</head>

<body>
   
   <div id="app" style="border: 1px solid;display: flex;flex-direction: column;flex: 0 1 100%;overflow-x: auto;margin: 0.4em;">
        <h1 style="text-align: center;color: red;">红色问答调试</h1>
        <!-- START OF MODIFIED BLOCK -->
        <div style="display: grid; grid-template-columns: auto 1fr; align-items: center; gap: 4px 8px; margin-bottom: 4px; padding: 0 0.5em;">
    <!-- 改动: 移除了 span 上的 justify-self: end; 样式，使其恢复默认左对齐 -->
    <span>平台:</span>
    <input v-model="platform" @input="change_platform">

    <span>机器人ID:</span>
    <input v-model="bot_id" @input="change_bot_id">

    <span>群组ID:</span>
    <input v-model="groups_id" @input="change_groups_id">

    <span>群ID:</span>
    <input v-model="group_id" @input="change_group_id">

    <span>用户ID:</span>
    <input v-model="user_id" @input="change_user_id">

    <span>包名(为空表示默认包):</span>
    <input v-model="pkg_name" @input="change_pkg_name">
</div>
        <!-- END OF MODIFIED BLOCK -->
        <div style="flex: 1 0 auto;height: 0;width: 100%; display: flex; flex-direction: column;">
            <quill-editor id="script_content" ref="child" theme="snow" spellcheck="false" style="height: 50%;"></quill-editor>
            <div style="display: flex;flex: 1 0 auto;height: 50%;flex-direction: row;overflow: auto; border-top: 1px solid;">
                <textarea style="flex-grow: 1;min-width: 50%; border: none; outline: none;" disabled>{{result}}</textarea>
                <div v-if="has_img" style="overflow: auto;width: 0;flex-grow: 1; padding: 5px; border-left: 1px solid #ccc;">
                    <!-- 次要改动: 修正了 img 标签的样式写法，并增加了宽度和边框 -->
                    <img v-bind:src="img_src" style="max-width: 100%; object-fit: scale-down;">
                </div>
            </div>
        </div>
        <div style="display: flex;flex: 0 0 auto;">
            <button style="height: 40px;font-size: medium;font-weight: bold;flex: 1 0 auto;" @click="run_script()">发送到平台</button>
            <button style="height: 40px;font-size: medium;font-weight: bold;flex: 1 0 auto;" @click="run_script2()">直接运行</button>
        </div>
   </div>
   <script>
    const { createApp } = Vue
    const app = createApp({
        data() {
            return {
                // 用于显示
                platform:"onebot11",
                bot_id:"1736293901",
                groups_id:"556515826",
                group_id:"556515826",
                pkg_name:"",
                user_id:"",
                result:"",
                img_src:"",
                has_img:false,
                last_code:"",
                last_change_time:(new Date()).valueOf(),
                last_index:0,
            }
        },
        mounted () {

            let platform_t = window.localStorage.getItem('debug_platform');
            if (platform_t) {
                this.platform = platform_t
            }else {
                this.platform = "onebot11"
            }
            let bot_id_t = window.localStorage.getItem('debug_bot_id');
            if (bot_id_t) {
                this.bot_id = bot_id_t
            }else {
                this.bot_id = "1736293901"
            }
            let groups_id_t = window.localStorage.getItem('debug_groups_id');
            if (groups_id_t) {
                this.groups_id = groups_id_t
            }else {
                this.groups_id = ""
            }
            let group_id_t = window.localStorage.getItem('debug_group_id');
            if (group_id_t) {
                this.group_id = group_id_t
            }else {
                this.group_id = "556515826"
            }
            let user_id_t = window.localStorage.getItem('debug_user_id');
            if (user_id_t) {
                this.user_id = user_id_t
            }else {
                this.user_id = ""
            }
            let pkg_name_t = window.localStorage.getItem('debug_pkg_name');
            if (pkg_name_t) {
                this.pkg_name = pkg_name_t
            }else {
                this.pkg_name = ""
            }

            setInterval(() => {
                const quill = this.$refs.child.getQuill();
                let sec = quill.getSelection()
                let curr_index = 0
                if(sec){
                    curr_index = sec.index
                }
                
                let code = quill.getText();
                const tm = (new Date()).valueOf()
                if ((code!= this.last_code || curr_index != this.last_index) && !this.composing && tm - this.last_change_time > 300) {
                    this.highlight()
                    this.last_code = code
                    this.last_index = curr_index
                }
            }, 500)
			
			const quill = this.$refs.child.getQuill();

			// 解决粘贴时缩进变少的问题
            quill.root.addEventListener('paste', (evt) => {
                evt.preventDefault();
                const text = (evt.clipboardData || window.clipboardData).getData('text/plain');
                const range = quill.getSelection(false); // 不自动修正
                if (range) {
                    if (range.length > 0) {
                        quill.deleteText(range.index, range.length, 'user');
                    }
                    quill.insertText(range.index, text, 'user');
                    quill.setSelection(range.index + text.length, 0, 'user');
                }
            }, true); 


            // 对复制进行hook，解决复制时多余的换行
            const ele = document.getElementById("script_content")
            ele.oncopy = (e) => {
                const quill = this.$refs.child.getQuill()
                const range = quill.getSelection()
                e.clipboardData.setData('text/plain', quill.getText(range.index, range.length));
                e.preventDefault();
            }
			
			// 对剪切进行hook，解决剪切时多余的换行
			ele.oncut = (e) => {
                const quill = this.$refs.child.getQuill();
                const range = quill.getSelection();
                if (range && range.length > 0) {
                    e.clipboardData.setData('text/plain', quill.getText(range.index, range.length));
                    quill.deleteText(range.index, range.length);
                }
                e.preventDefault();
            };
            
             // 处理中文输入
            ele.addEventListener('compositionstart',(e) =>{
                this.composing = true
                console.log('compositionstart')
            })
            ele.addEventListener('compositionend',(e) =>{    
                this.composing = false
                console.log('compositionend')
                this.last_change_time = (new Date()).valueOf()
            })

                        // 处理Tab键缩进和反缩进 - 使用事件捕获确保优先处理
            document.addEventListener('keydown', (e) => {
                // 检查焦点是否在Quill编辑器内
                if (!quill.root.contains(document.activeElement) && document.activeElement !== quill.root) {
                    return;
                }
                
                if (e.key === 'Tab') {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    console.log('Tab key detected:', e.shiftKey ? 'Shift+Tab' : 'Tab');
                    
                    const range = quill.getSelection();
                    
                    if (!range) {
                        console.log('No selection range');
                        return;
                    }
                    
                    console.log('Selection range:', range);
                    
                    if (e.shiftKey) {
                        // Shift+Tab：反缩进
                        console.log('Performing outdent');
                        if (range.length === 0) {
                            // 没有选中文本时，删除光标前的缩进（最多4个空格）
                            const text = quill.getText();
                            let deleteCount = 0;
                            for (let i = 1; i <= 4 && range.index - i >= 0; i++) {
                                if (text[range.index - i] === ' ') {
                                    deleteCount++;
                                } else {
                                    break;
                                }
                            }
                            if (deleteCount > 0) {
                                quill.deleteText(range.index - deleteCount, deleteCount, 'user');
                                quill.setSelection(range.index - deleteCount, 0, 'user');
                            }
                        } else {
                            // 有选中文本时，对每行移除缩进
                            const text = quill.getText();
                            
                            // 找到选中区域开始的行首位置
                            let startLineIndex = range.index;
                            while (startLineIndex > 0 && text[startLineIndex - 1] !== '\n') {
                                startLineIndex--;
                            }
                            
                            // 找到选中区域结束的行尾位置
                            let endLineIndex = range.index + range.length;
                            if (endLineIndex < text.length && text[endLineIndex - 1] !== '\n') {
                                while (endLineIndex < text.length && text[endLineIndex] !== '\n') {
                                    endLineIndex++;
                                }
                            }
                            
                            // 获取需要反缩进的完整文本
                            const fullSelectedText = text.substring(startLineIndex, endLineIndex);
                            const lines = fullSelectedText.split('\n');
                            
                            // 对每行移除缩进（最多4个空格）并记录每行移除的空格数
                            const spacesRemovedPerLine = [];
                            const outdentedLines = lines.map((line, index) => {
                                let spacesToRemove = 0;
                                for (let i = 0; i < Math.min(4, line.length); i++) {
                                    if (line[i] === ' ') {
                                        spacesToRemove++;
                                    } else {
                                        break;
                                    }
                                }
                                spacesRemovedPerLine[index] = spacesToRemove;
                                return line.substring(spacesToRemove);
                            });
                            
                            const outdentedText = outdentedLines.join('\n');
                            
                            // 替换文本
                            quill.deleteText(startLineIndex, endLineIndex - startLineIndex, 'user');
                            quill.insertText(startLineIndex, outdentedText, 'user');
                            
                            // 重新计算选中范围：保持用户原始选择的相对位置
                            const originalSelectionStartOffset = range.index - startLineIndex;
                            const originalSelectionEndOffset = (range.index + range.length) - startLineIndex;
                            
                            // 计算第一行移除的空格数，用于调整选择开始位置
                            const firstLineRemovedSpaces = spacesRemovedPerLine[0] || 0;
                            
                            // 计算总共移除的空格数
                            const totalRemovedSpaces = spacesRemovedPerLine.reduce((sum, spaces) => sum + spaces, 0);
                            
                            // 计算反缩进后用户选择应该开始和结束的位置
                            let newSelectionStart = startLineIndex + originalSelectionStartOffset - firstLineRemovedSpaces;
                            let newSelectionEnd = startLineIndex + originalSelectionEndOffset - totalRemovedSpaces;
                            
                            // 确保选中范围在有效范围内
                            newSelectionStart = Math.max(startLineIndex, newSelectionStart);
                            const maxIndex = startLineIndex + outdentedText.length;
                            newSelectionEnd = Math.min(newSelectionEnd, maxIndex);
                            
                            const newSelectionLength = Math.max(0, newSelectionEnd - newSelectionStart);
                            quill.setSelection(newSelectionStart, newSelectionLength, 'user');
                        }
                    } else {
                        // Tab：缩进
                        console.log('Performing indent');
                        if (range.length === 0) {
                            // 没有选中文本时，插入4个空格作为缩进
                            quill.insertText(range.index, '    ', 'user');
                            quill.setSelection(range.index + 4, 0, 'user');
                        } else {
                            // 有选中文本时，对每行添加缩进
                            const text = quill.getText();
                            
                            // 找到选中区域开始的行首位置
                            let startLineIndex = range.index;
                            while (startLineIndex > 0 && text[startLineIndex - 1] !== '\n') {
                                startLineIndex--;
                            }
                            
                            // 找到选中区域结束的行尾位置
                            let endLineIndex = range.index + range.length;
                            if (endLineIndex < text.length && text[endLineIndex - 1] !== '\n') {
                                while (endLineIndex < text.length && text[endLineIndex] !== '\n') {
                                    endLineIndex++;
                                }
                            }
                            
                            // 获取需要缩进的完整文本
                            const fullSelectedText = text.substring(startLineIndex, endLineIndex);
                            const lines = fullSelectedText.split('\n');
                            
                            // 对每行添加4个空格的缩进
                            const indentedText = lines.map(line => {
                                return '    ' + line;
                            }).join('\n');
                            
                            // 替换文本
                            quill.deleteText(startLineIndex, endLineIndex - startLineIndex, 'user');
                            quill.insertText(startLineIndex, indentedText, 'user');
                            
                            // 重新计算选中范围：保持用户原始选择的相对位置
                            const originalSelectionStartOffset = range.index - startLineIndex;
                            const originalSelectionEndOffset = (range.index + range.length) - startLineIndex;
                            
                            // 计算缩进后用户选择应该开始和结束的位置
                            let newSelectionStart = startLineIndex + originalSelectionStartOffset + 4; // 第一行增加了4个空格
                            let newSelectionEnd = startLineIndex + originalSelectionEndOffset + (lines.length * 4); // 每行都增加了4个空格
                            
                            // 确保选中范围在有效范围内
                            const maxIndex = startLineIndex + indentedText.length;
                            newSelectionStart = Math.min(newSelectionStart, maxIndex);
                            newSelectionEnd = Math.min(newSelectionEnd, maxIndex);
                            
                            const newSelectionLength = newSelectionEnd - newSelectionStart;
                            quill.setSelection(newSelectionStart, newSelectionLength, 'user');
                        }
                    }
                }
            }, true); // 使用事件捕获

            quill.on('text-change', (delta, oldDelta, source) => {
                if (source == 'user') {
                    if(!this.composing){
                        this.last_change_time = (new Date()).valueOf()
                    }
                }
            });
            quill.on('selection-change', (range, oldDelta, source) => {
                if (source == 'user') {
                    if(!this.composing){
                        this.last_change_time = (new Date()).valueOf()
                    }
                }
            });
        },
        methods: {
            change_platform(){
                window.localStorage.setItem('debug_platform',this.platform)
            },
            change_bot_id(){
                window.localStorage.setItem('debug_bot_id',this.bot_id)
            },
            change_group_id(){
                window.localStorage.setItem('debug_group_id',this.group_id)
            },
            change_user_id(){
                window.localStorage.setItem('debug_user_id',this.user_id)
            },
            change_groups_id(){
                window.localStorage.setItem('debug_groups_id',this.groups_id)
            },
            change_pkg_name(){
                window.localStorage.setItem('debug_pkg_name',this.pkg_name)
            },
            run_script(){
                let content = this.$refs.child.getQuill().getText();
                let script = {
                    "platform":this.platform,
                    "bot_id":this.bot_id,
                    "groups_id":this.groups_id,
                    "group_id":this.group_id,
                    "user_id":this.user_id,
                    "content":content,
                    "pkg_name":this.pkg_name
                }
                this.result = "正在提交..."
                axios.post("/run_code",script)
                .then((res) => {
                    if(res.data['retcode'] == 0){
                        this.result = "请求已提交"
                    }else {
                        this.result = "提交失败：" + res.data
                    }
                })
                .catch( (error) => { // 'this' context issue fixed
                    this.result = "提交失败: " + error
                });
            },
            run_script2(){
                let content = this.$refs.child.getQuill().getText();
                let script = {
                    "platform":this.platform,
                    "bot_id":this.bot_id,
                    "groups_id":this.groups_id,
                    "group_id":this.group_id,
                    "user_id":this.user_id,
                    "content":content,
                    "pkg_name":this.pkg_name
                }
                this.result = "正在执行..."
                this.has_img = false
                axios.post("/run_code_and_ret",script)
                .then((res) => {
                    if(res.data['retcode'] == 0){
                        this.result = res.data["data"]
                        var reg = /\[CQ:image,file=(.*?)(\]|\,)/;
                        let ret = reg.exec(this.result)
                        if(ret && ret.length > 1) { // Added check for ret
                            let img = ret[1].trim()
                            if(img.startsWith("base64://")) {
                                this.img_src = "data:image/jpeg;base64," + img.slice(9)
                                this.has_img = true;
                            } else {
                                let img2 = img.replaceAll("[", '[')
                                    .replaceAll("#93;", ']')
                                    .replaceAll(",", ',')
                                    .replaceAll("&", '&')
                                this.img_src = img2
                                this.has_img = true;
                            }
                        }
                        
                    }else {
                        this.result = "执行失败：" + res.data['data']
                    }
                })
                .catch((error) => { // 'this' context issue fixed
                    this.result = "执行失败: " + error
                });
            },
            highlight()
            {
                var current_color = 0;
                function next_color(){
                    current_color = (current_color + 1) % 4;
                }
                function pre_color(){
                    current_color = (current_color + 3) % 4;
                }
                var colorList = ["#000000","#FF0000","#0000FF","#008000"]
                function ColorReverse(OldColorValue){
                    var OldColorValue = "0x"+OldColorValue.replace(/#/g,"");
                    var str="000000"+(0xFFFFFF-OldColorValue).toString(16);
                    return '#' + str.substring(str.length-6,str.length);
                }

                quill = this.$refs.child.getQuill();
                
                let range = quill.getSelection();
                let curr_index = range ? range.index : 0;

                let code = quill.getText();
                
                quill.disable();
                
                // Clear all existing color and background formats
                quill.formatText(0, code.length, {
                    color: false,
                    background: false
                }, 'silent');

                // Apply new formats segment by segment
                let start = 0;
                current_color = 0;
                for (let i = 0; i < code.length; i++) {
                    let length_to_apply = i - start;
                    if (code[i] === '【') {
                        if (length_to_apply > 0) {
                            quill.formatText(start, length_to_apply, {color: colorList[current_color]}, 'silent');
                        }
                        next_color();
                        quill.formatText(i, 1, {color: colorList[current_color]}, 'silent');
                        start = i + 1;
                    } else if (code[i] === '】') {
                        if (length_to_apply > 0) {
                            quill.formatText(start, length_to_apply, {color: colorList[current_color]}, 'silent');
                        }
                        quill.formatText(i, 1, {color: colorList[current_color]}, 'silent');
                        pre_color();
                        start = i + 1;
                    } else if (code[i] === '\\') {
                        if (length_to_apply > 0) {
                            quill.formatText(start, length_to_apply, {color: colorList[current_color]}, 'silent');
                        }
                        i++; // assume next char exists
                        if (i < code.length) {
                            quill.formatText(i - 1, 2, {color: colorList[current_color]}, 'silent');
                            start = i + 1;
                        } else {
                            quill.formatText(i - 1, 1, {color: colorList[current_color]}, 'silent');
                            start = i;
                        }
                    }
                    // normal char, continue accumulating
                }
                // Apply last segment
                if (start < code.length) {
                    quill.formatText(start, code.length - start, {color: colorList[current_color]}, 'silent');
                }

                // Handle cursor highlight
                if (curr_index >= 0 && curr_index < code.length) {
                    let pos = curr_index;
                    if (code[pos] !== '【' && code[pos] !== '】') {
                        if (pos > 0) pos--;
                    }
                    if (code[pos] === '【' || code[pos] === '】') {
                        // Find matching
                        let direction = code[pos] === '【' ? 1 : -1;
                        let bracket = code[pos] === '【' ? '【' : '】';
                        let matchBracket = bracket === '【' ? '】' : '【';
                        let count = 1;
                        let matchPos = pos + direction;
                        while (matchPos >= 0 && matchPos < code.length) {
                            if (code[matchPos] === '\\') {
                                matchPos += direction;
                            } else if (code[matchPos] === bracket) {
                                count++;
                            } else if (code[matchPos] === matchBracket) {
                                count--;
                                if (count === 0) {
                                    break;
                                }
                            }
                            matchPos += direction;
                        }
                        if (count === 0 && matchPos >= 0 && matchPos < code.length) {
                            // Apply background to pos and matchPos
                            let colorAtPos = quill.getFormat(pos, 1).color || '#000000';
                            let bg = ColorReverse(colorAtPos);
                            quill.formatText(pos, 1, {background: bg}, 'silent');
                            quill.formatText(matchPos, 1, {background: bg}, 'silent');
                        }
                    }
                }
                
                quill.enable();
                quill.setSelection(range);
            },
        }
    })
    const globalOptions = {
        history: {
            delay: 2000,
            maxStack: 100,
            userOnly: true
        },
        modules: {
            toolbar: "",
             keyboard: {
                bindings: {
                    'list autofill': {
                        key: ' ',
                        prefix: /^-$/,
                        handler: () => true
                    }
                }
            }
        },
        placeholder: '脚本内容',
        theme: 'snow'
    }
    VueQuill.QuillEditor.props.globalOptions.default = () => globalOptions
    app.component('QuillEditor', VueQuill.QuillEditor);
    app.mount('#app')
   </script>
   
</body>

</html>